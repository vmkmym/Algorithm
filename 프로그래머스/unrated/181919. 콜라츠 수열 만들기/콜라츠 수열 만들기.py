def solution(n):
    collatz = [n]
    
    while n != 1:
        n = n // 2 if n % 2 == 0 else 3 * n + 1
        collatz.append(n)

    return collatz

# 콜라츠 수열 재밌다..
# 처음에 초기값 안넣어줘서 틀리다가 넣어주고 맞춤
# gpt가 알려주는 풀이를 다른 사람 풀이에서 못봐서 참고 안하기로 함.

### 콜라츠 수열이란?

# 콜라츠 수열 문제를 최적으로 푸는 방법은 모든 자연수에 대해 콜라츠 수열의 길이를 구하는 것입니다. 
# 그리고 이미 계산된 수열의 길이를 저장하여 중복 계산을 피하는 등의 방법으로 효율적인 알고리즘을 구현하는 것이 중요합니다. 
# 예를 들어, 메모이제이션(memoization)을 사용하여 이미 계산된 값들을 저장하고 활용하는 방법이 효율적인 방법 중 하나입니다. 
# 이렇게 함으로써 중복 계산을 피하고 수열의 길이를 빠르게 계산할 수 있습니다.

### 메모이제이션이란?

# 메모이제이션(memoization)은 프로그램이 동일한 계산을 반복할 때, 
# 이전에 계산한 값을 저장함으로써 동일한 계산을 다시 수행하지 않도록 하는 최적화 기법입니다. 
# 주로 동적 계획법(Dynamic Programming)과 관련하여 사용되며, 중복 계산을 피해 실행 시간을 줄이는 데에 활용됩니다.
# 메모이제이션은 캐시(cache) 형태로 이전에 계산한 값을 저장하고, 
# 나중에 동일한 입력값에 대한 결과가 필요할 때 저장된 값을 활용하여 중복 계산을 피합니다.

###  간단한 예시, 피보나치 수열, 메모이제이션 이용
def fibonacci(n):
    # 계산된 값을 저장할 딕셔너리
    memo = {} 
    
    if n <= 1:
        return n
    if n not in memo:
        memo[n] = fibonacci(n - 1) + fibonacci(n - 2)
    return memo[n]

# 함수가 호출될 때마다 memo에 해당 값이 이미 계산되었는지를 확인하고, 
# 계산된 값이 있다면 해당 값을 바로 반환하여 중복 계산을 피합니다. 
# 이렇게 함으로써 동일한 계산을 반복하지 않고 효율적으로 값을 구할 수 있습니다.
